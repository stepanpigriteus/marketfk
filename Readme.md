# MarketFlow - система обработки рыночных данных в реальном времени

MarketFlow - это система, предназначенная для обработки рыночных данных криптовалют в режиме реального времени, которая обеспечивает эффективное получение, параллельную обработку, хранение и доступ к данным через REST API.

## Особенности

- Параллельная обработка данных с использованием паттернов конкурентности Go
- Два режима работы: Live Mode (данные с бирж) и Test Mode (синтетические данные)
- Хранение данных в PostgreSQL и кэширование в Redis
- REST API для доступа к текущим и историческим ценам
- Гексагональная архитектура для лучшей масштабируемости и тестируемости

## Архитектура

Проект реализован с использованием гексагональной (портов и адаптеров) архитектуры:

```
           ┌─────────────────────────────────────────────┐
           │            Infrastructure Layer             │
           │                                             │
           │  ┌─────────────┐        ┌───────────────┐   │
           │  │   HTTP API  │        │ CLI Interface │   │
           │  └──────┬──────┘        └───────┬───────┘   │
           │         │                       │           │
           └─────────┼───────────────────────┼───────────┘
                     │                       │
                     ▼                       ▼
           ┌─────────────────────────────────────────────┐
           │              Adapters Layer                 │
           │                                             │
           │  ┌──────────────┐       ┌──────────────┐    │
           │  │ Input Ports  │       │ Output Ports │    │
           │  └──────┬───────┘       └───────┬──────┘    │
           │         │                       │           │
           └─────────┼───────────────────────┼───────────┘
                     │                       │
                     ▼                       ▼
           ┌─────────────────────────────────────────────┐
           │             Application Layer               │
           │                                             │
           │      ┌────────────────────────────┐         │
           │      │        Use Cases           │         │
           │      └────────────────────────────┘         │
           │                                             │
           └───────────────────┬─────────────────────────┘
                               │
                               ▼
           ┌─────────────────────────────────────────────┐
           │              Domain Layer                   │
           │                                             │
           │  ┌──────────────┐       ┌──────────────┐    │
           │  │   Entities   │       │   Services   │    │
           │  └──────────────┘       └──────────────┘    │
           │                                             │
           └─────────────────────────────────────────────┘
```

### Domain Layer (Доменный слой)

Содержит бизнес-логику и модели, независимые от внешних факторов:
- Сущности (Entities): модели данных, представляющие концепции предметной области
- Сервисы (Services): реализация бизнес-правил и операций

### Application Layer (Прикладной слой)

Координирует выполнение бизнес-операций:
- Use Cases: реализуют сценарии использования системы
- Порты: определяют интерфейсы для взаимодействия с внешними компонентами

### Adapters Layer (Слой адаптеров)

Соединяет доменную логику с внешними сервисами:
- Input Adapters: получают запросы от клиентов (HTTP API)
- Output Adapters: отправляют запросы к внешним системам (БД, Redis, биржи)

### Infrastructure Layer (Инфраструктурный слой)

Обеспечивает техническую поддержку для адаптеров:
- HTTP Framework
- Конфигурация
- Логирование
- Управление подключениями

## Структура проекта

```
marketflow/
├── cmd/
│   └── marketflow/                 # Точка входа приложения
│       └── main.go                 # Основной исполняемый файл
├── config/                         # Конфигурация приложения
│   ├── config.go                   # Парсинг и валидация конфигурации
│   └── config.yaml                 # Файл конфигурации
├── internal/                       # Внутренние пакеты приложения
│   ├── domain/                     # Доменный слой
│   │   ├── model/                  # Доменные модели
│   │   │   ├── price.go            # Модель данных цены
│   │   │   └── statistics.go       # Модель статистики цен
│   │   └── service/                # Сервисы доменной логики
│   │       └── market_service.go   # Сервис обработки рыночных данных
│   ├── application/                # Прикладной слой
│   │   ├── usecase/                # Варианты использования
│   │   │   ├── price_usecase.go    # Получение цен
│   │   │   └── mode_usecase.go     # Управление режимами работы
│   │   └── port/                   # Порты (интерфейсы)
│   │       ├── in/                 # Входные порты
│   │       │   └── api_port.go     # Интерфейсы для API
│   │       └── out/                # Выходные порты
│   │           ├── cache_port.go   # Интерфейс для кэширования
│   │           ├── storage_port.go # Интерфейс для хранилища
│   │           └── exchange_port.go # Интерфейс для источника данных
│   └── adapter/                    # Адаптеры
│       ├── in/                     # Входные адаптеры
│       │   └── api/                # API адаптеры
│       │       ├── handler/        # Обработчики HTTP запросов
│       │       │   ├── price_handler.go # Обработчик запросов цен
│       │       │   ├── mode_handler.go  # Обработчик смены режимов
│       │       │   └── health_handler.go # Обработчик проверки состояния
│       │       ├── middleware/     # Middleware для API
│       │       │   ├── logging.go  # Логирование запросов
│       │       │   └── recovery.go # Восстановление после паники
│       │       └── router.go       # Настройка маршрутизации
│       └── out/                    # Выходные адаптеры
│           ├── cache/              # Адаптер кэша
│           │   └── redis_adapter.go # Адаптер для Redis
│           ├── storage/            # Адаптер хранилища
│           │   └── postgres_adapter.go # Адаптер для PostgreSQL
│           └── exchange/           # Адаптеры источников данных
│               ├── live/           # Адаптеры для режима Live
│               │   ├── client.go   # Клиент для подключения к биржам
│               │   └── exchange_adapter.go # Адаптер для бирж
│               └── test/           # Адаптеры для тестового режима
│                   └── generator.go # Генератор тестовых данных
├── pkg/                           # Публичные пакеты
│   ├── logger/                    # Пакет для логирования
│   │   └── logger.go              # Настройка логирования
│   └── utils/                     # Утилиты
│       ├── shutdown.go            # Корректное завершение работы
│       └── helpers.go             # Вспомогательные функции
└── scripts/                       # Скрипты для запуска и тестирования
    ├── start_exchanges.sh         # Скрипт для запуска эмуляций бирж
    └── init_db.sql                # SQL для инициализации БД
```

## План реализации

### 1. Настройка базовой структуры проекта
- [ ] Создать базовую структуру каталогов
- [ ] Настроить go.mod и go.sum
- [ ] Создать main.go с базовым функционалом запуска
- [ ] Реализовать обработку командной строки и вывод справки (--help)

### 2. Конфигурация и логирование
- [ ] Реализовать структуру конфигурации
- [ ] Добавить чтение конфигурации из файла
- [ ] Настроить логирование с использованием log/slog
- [ ] Реализовать механизм корректного завершения работы

### 3. Доменный слой
- [ ] Определить основные доменные модели (Price, Statistics)
- [ ] Реализовать доменные сервисы
- [ ] Определить бизнес-правила обработки данных

### 4. Порты (интерфейсы)
- [ ] Определить входные порты для API
- [ ] Определить выходные порты для кэша
- [ ] Определить выходные порты для хранилища
- [ ] Определить выходные порты для источников данных

### 5. Адаптеры для источников данных
- [ ] Реализовать адаптер для подключения к биржам (Live Mode)
- [ ] Реализовать обработку ошибок и повторное подключение
- [ ] Создать генератор тестовых данных (Test Mode)
- [ ] Реализовать переключение между режимами

### 6. Обработка данных и параллелизм
- [ ] Реализовать шаблон Fan-Out (распределитель) для каждого источника
- [ ] Создать пул рабочих (Worker Pool) для обработки данных
- [ ] Реализовать шаблон Fan-In (агрегатор) для сбора результатов
- [ ] Добавить буферизацию данных перед записью в БД

### 7. Адаптеры для хранения и кэширования
- [ ] Реализовать PostgreSQL адаптер
- [ ] Создать схему БД с необходимыми таблицами
- [ ] Реализовать Redis адаптер для кэширования 
- [ ] Реализовать механизм резервного сохранения при недоступности Redis

### 8. Сбор и агрегация статистики
- [ ] Реализовать расчет средней цены за минуту
- [ ] Реализовать отслеживание минимальной и максимальной цены
- [ ] Настроить периодическое сохранение агрегированных данных
- [ ] Реализовать очистку устаревших данных

### 9. REST API
- [ ] Реализовать обработчики для получения текущих цен
- [ ] Реализовать обработчики для получения статистики
- [ ] Добавить обработчики для переключения режимов
- [ ] Реализовать проверку состояния системы (health check)

### 10. Прикладной слой (Use Cases)
- [ ] Реализовать варианты использования для получения цен
- [ ] Реализовать варианты использования для управления режимами
- [ ] Соединить входные адаптеры с вариантами использования

### 11. Тестирование и документация
- [ ] Написать юнит-тесты для доменного слоя
- [ ] Написать интеграционные тесты для адаптеров
- [ ] Документировать API и порядок работы с системой

## Использование паттернов параллелизма

Проект использует следующие паттерны для эффективной обработки параллельных потоков данных:

1. **Fan-Out**: Распределение данных от каждого источника между несколькими обработчиками
2. **Worker Pool**: Пул рабочих процессов для параллельной обработки данных
3. **Fan-In**: Объединение результатов от всех обработчиков в один канал
4. **Generator**: Генерация синтетических данных для тестового режима

```
                      +---------------+       +---------------+       +---------------+
                      |  Source 1     |       |  Source 2     |       |  Source 3     |
                      |  (Generator)  |       |  (Generator)  |       |  (Generator)  |
                      +-------+-------+       +-------+-------+       +-------+-------+
                              |                       |                       |
                              v                       v                       v
                      +-------+-------+       +-------+-------+       +-------+-------+
                      |   Fan-Out 1   |       |   Fan-Out 2   |       |   Fan-Out 3   |
                      |  (Distributor)|       |  (Distributor)|       |  (Distributor)|
                      +---+---+---+---+       +---+---+---+---+       +---+---+---+---+
                          |   |   |               |   |   |               |   |   |
          +---------------+-+-+-+-+-+-------------+-+-+-+-+-+---------------------------+
          |               | | | | | |                 | | | | | |                       |
          v               v v v v v v                 v v v v v v                       v
      +---+---+       +---+---+---+---+-----+       +---+---+---+---+---+---+       +---+---+
      |Worker1|       |Worker2| ... |WorkerN|       |WorkerN+1| ... |WorkerM|      |WorkerM+1|
      +---+---+       +---+---+---+---+-----+       +---+---+---+---+---+---+       +---+---+
          |               |                   ...       |                   ...         |
          +---------------+-----------------------------+-------------------------------+
                              | (all output channels)
                              v
                      +-------+-------+
                      |    Fan-In     |
                      |  (Aggregator) |
                      +-------+-------+
                              | (resultCh)
                              v
                      +-------+-------+
                      |   Receiver    |
                      | (Collector)   |
                      +---------------+
```

## Требования

- Go 1.21+
- PostgreSQL 14+
- Redis 7+
- Docker (для эмуляции бирж)

## Установка и запуск

1. Клонировать репозиторий:
```bash
git clone https://github.com/yourusername/marketflow.git
cd marketflow
```

2. Создать и настроить файл конфигурации:
```bash
cp config/config.example.yaml config/config.yaml
# Редактировать config.yaml под свои нужды
```

3. Запустить PostgreSQL и Redis:
```bash
# Используйте Docker или локальные установки
docker-compose up -d postgres redis
```

4. Запустить эмуляции бирж:
```bash
# Для amd64
scripts/start_exchanges.sh amd64
# Или для arm64
scripts/start_exchanges.sh arm64
```

5. Собрать и запустить приложение:
```bash
go build -o marketflow ./cmd/marketflow
./marketflow --port 8080
```

## API Endpoints

### Цены и статистика

- `GET /prices/latest/{symbol}` - Получить последнюю цену для символа
- `GET /prices/latest/{exchange}/{symbol}` - Последняя цена с конкретной биржи
- `GET /prices/highest/{symbol}` - Максимальная цена за период
- `GET /prices/highest/{exchange}/{symbol}` - Максимальная цена с конкретной биржи
- `GET /prices/lowest/{symbol}` - Минимальная цена за период
- `GET /prices/lowest/{exchange}/{symbol}` - Минимальная цена с конкретной биржи
- `GET /prices/average/{symbol}` - Средняя цена за период
- `GET /prices/average/{exchange}/{symbol}` - Средняя цена с конкретной биржи

Все эндпоинты поддерживают параметр `period` для указания временного интервала (например, `?period=5m`).

### Управление режимами

- `POST /mode/test` - Переключиться в тестовый режим
- `POST /mode/live` - Переключиться в режим реального времени

### Состояние системы

- `GET /health` - Получить информацию о состоянии системы

## Лицензия

MIT
