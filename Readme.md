# MarketFlow - Структура проекта и пошаговый план

## Структура проекта (Гексагональная архитектура)

```
marketflow/
├── cmd/                   # Точки входа в приложение (исполняемые файлы)
│   ├── marketflow/        # Основной бинарник приложения
│   │   └── main.go        # Инициализация и запуск приложения, выбор профиля, DI-контейнер
│   └── testgen/           # Генератор тестовых данных
│       └── main.go        # Логика генерации тестовых данных для эмуляции биржи
│
├── internal/              # Внутренний код приложения, не предназначенный для импорта
│   ├── domain/            # Доменный слой - бизнес-логика и правила
│   │   ├── model/         # Доменные модели - основные сущности бизнес-логики
│   │   │   ├── market.go  # Модели рыночных данных (Price, Pair, Order, etc.)
│   │   │   └── exchange.go # Модель биржи (Exchange, ExchangeInfo, etc.)
│   │   └── service/       # Доменные сервисы - основная бизнес-логика
│   │       └── market.go  # Сервис обработки рыночных данных (расчеты, анализ)
│   │
│   ├── application/       # Прикладной слой - реализует сценарии использования
│   │   ├── usecase/       # Реализация сценариев использования (бизнес-операций)
│   │   │   ├── price_fetcher.go   # Получение цен с бирж, реализация входного порта
│   │   │   ├── price_aggregator.go # Агрегация цен, реализация входного порта
│   │   │   └── mode_manager.go    # Управление режимами, реализация входного порта
│   │   └── port/          # Порты для адаптеров (интерфейсы)
│   │       ├── in/        # Входные порты (интерфейсы для входящих адаптеров)
│   │       │   ├── price_service.go  # Интерфейс PriceService
│   │       │   ├── mode_service.go   # Интерфейс ModeService
│   │       │   ├── health_service.go # Интерфейс HealthService
│   │       │   ├── http.go    # Интерфейсы для REST API
│   │       │   └── exchange.go # Интерфейсы для обработки данных с бирж
│   │       └── out/      # Выходные порты (интерфейсы для исходящих адаптеров)
│   │           ├── storage.go  # Интерфейс для хранилища (Repository)
│   │           ├── cache.go    # Интерфейс для кеша (CacheClient)
│   │           └── exchange.go # Интерфейс для получения данных с бирж (ExchangeClient)
│   │
│   └── adapter/          # Адаптеры - соединяют внешний мир с приложением
│       ├── in/           # Входящие адаптеры - преобразуют внешние запросы в вызовы приложения
│       │   ├── http/     # HTTP адаптер - REST API
│       │   │   ├── handler/ # Обработчики запросов
│       │   │   │   ├── price.go   # Обработчики для цен, использует PriceService
│       │   │   │   ├── mode.go    # Обработчики для режимов, использует ModeService
│       │   │   │   └── health.go  # Обработчик для проверки здоровья, использует HealthService
│       │   │   ├── server.go # HTTP сервер (конфигурация, middleware)
│       │   │   └── router.go # Роутер (маршрутизация запросов)
│       │   └── exchange/    # Адаптеры для бирж
│       │       ├── live/    # Адаптер для живых данных
│       │       │   └── connector.go # Коннектор к биржам (подписка на данные)
│       │       └── test/    # Адаптер для тестовых данных
│       │           └── connector.go # Коннектор к тест-генератору
│       └── out/          # Исходящие адаптеры - преобразуют вызовы приложения во внешние
│           ├── storage/  # Адаптер хранилища
│           │   └── postgres/ # PostgreSQL адаптер
│           │       ├── repository.go # Репозиторий (реализация порта storage.go)
│           │       └── mapper.go    # Маппер данных (DTO <-> Domain)
│           ├── cache/    # Адаптер кеша
│           │   └── redis/  # Redis адаптер
│           │       ├── cache.go  # Реализация кеша (реализация порта cache.go)
│           │       └── mapper.go # Маппер данных (DTO <-> Domain)
│           └── exchange/ # Адаптер для получения данных с бирж
│               ├── live/ # Живой обмен
│               │   └── client.go # Клиент для подключения (реализация порта exchange.go)
│               └── test/ # Тестовый обмен
│                   └── client.go # Клиент для подключения (реализация порта exchange.go)
│
├── pkg/                 # Общие пакеты, которые могут быть использованы другими проектами
│   ├── config/          # Конфигурация
│   │   ├── config.go    # Модель конфигурации (структуры для настроек)
│   │   └── loader.go    # Загрузчик конфигурации (из файлов, env)
│   ├── concurrency/     # Утилиты для конкурентности
│   │   ├── fan_in.go    # Fan-In шаблон (объединение потоков данных)
│   │   ├── fan_out.go   # Fan-Out шаблон (распределение потоков данных)
│   │   └── worker_pool.go # Worker Pool шаблон (пул обработчиков)
│   │   └── gen_aggr.go  # создание каналов, запуск воркеров и т.д.Извлечение данных из fan-in 
│   └── logger/          # Логирование
│       └── logger.go    # Настройка логгера (с уровнями, форматами)
│
├── deployments/         # Конфигурация для развертывания
│   ├── docker-compose.yml # Docker Compose для запуска всех компонентов
│   ├── Dockerfile       # Dockerfile для сборки образа приложения
│
│
├── test/                # Тесты
│   ├── integration/     # Интеграционные тесты
│   └── e2e/             # End-to-End тесты
├── setup_structure.sh
├── sources             # Исходники бирж
│   ├── exchange1
│   │   └── exchange1_amd64.tar
│   ├── exchange2
│   │   └── exchange2_amd64.tar
│   └── exchange3
│       └── exchange3_amd64.tar
├── .gitignore           # Файлы, игнорируемые Git
├── Makefile             # Makefile для автоматизации задач
├── README.md            # Описание проекта
├── go.mod               # Go модули
└── go.sum               # Хеши модулей
```

## Пошаговый план реализации (TODO)

### Этап 1: Настройка проекта и базовая структура

1. **Настройка проекта**
   - Создать директорию проекта и инициализировать Go модуль
   - Настроить .gitignore файл
   - Создать базовые директории согласно структуре

2. **Реализация системы конфигурации**
   - Создать структуру для хранения конфигурации (PostgreSQL, Redis, порты и т.д.)
   - Реализовать загрузку конфигурации из файла

3. **Настройка логирования**
   - Создать пакет для логирования с использованием log/slog
   - Реализовать разные уровни логирования и форматирование

### Этап 2: Доменный слой

1. **Реализация доменных моделей**
   - Создать модель для рыночных данных (MarketData)
   - Создать модель для бирж (Exchange)
   - Создать модель для торговых пар (TradingPair)

2. **Реализация основных доменных сервисов**
   - Создать сервис для обработки рыночных данных
   - Реализовать базовую бизнес-логику

### Этап 3: Прикладной слой

1. **Определение портов (интерфейсов)**
   - Создать входные порты для REST API
   - Создать выходные порты для хранилища, кеша и подключения к биржам

2. **Реализация use-cases**
   - Реализовать получение цен с бирж
   - Реализовать агрегацию и обработку цен
   - Реализовать переключение между режимами (Live/Test)

### Этап 4: Адаптеры для хранения данных

1. **Реализация PostgreSQL адаптера**
   - Создать схему базы данных
   - Реализовать репозиторий для сохранения и получения данных
   - Реализовать пакетное сохранение данных

2. **Реализация Redis адаптера**
   - Реализовать кеширование последних цен
   - Реализовать хранение временных рядов для расчета средних значений
   - Настроить автоматическое удаление устаревших данных

### Этап 5: Адаптеры для подключения к биржам

1. **Реализация адаптера для живых данных**
   - Создать клиент для подключения к биржам по TCP
   - Реализовать парсинг данных
   - Реализовать механизм переподключения при обрыве связи

2. **Реализация генератора тестовых данных**
   - Создать отдельное приложение для генерации синтетических данных
   - Реализовать TCP сервер, имитирующий биржи
   - Настроить генерацию данных для заданных торговых пар

### Этап 6: Реализация паттернов конкурентности

1. **Fan-In Pattern**
   - Реализовать агрегацию данных с разных источников в один канал

2. **Fan-Out Pattern**
   - Реализовать распределение данных между обработчиками

3. **Worker Pool**
   - Создать пул воркеров для обработки входящих данных
   - Настроить балансировку нагрузки между воркерами

### Этап 7: REST API

1. **Реализация HTTP-сервера**
   - Настроить роутинг
   - Реализовать middleware для логирования, обработки ошибок и т.д.

2. **Реализация обработчиков для API точек**
   - Реализовать получение последних цен
   - Реализовать получение максимальных/минимальных/средних цен
   - Реализовать переключение режимов
   - Реализовать проверку состояния системы

### Этап 8: Корректное завершение работы

1. **Реализация graceful shutdown**
   - Обработка сигналов SIGINT и SIGTERM
   - Корректное закрытие всех соединений
   - Завершение всех горутин

### Этап 9: Сборка и упаковка

1. **Написание Dockerfile**
   - Создать Dockerfile для сборки образа

2. **Создание Docker Compose**
   - Настроить docker-compose.yml для запуска всей системы
   - Включить PostgreSQL, Redis и MarketFlow в одной конфигурации

### Этап 10: Тестирование

1. **Написание модульных тестов**
   - Протестировать основные компоненты системы

2. **Интеграционное тестирование**
   - Протестировать взаимодействие между компонентами

3. **Нагрузочное тестирование**
   - Проверить производительность системы при высокой нагрузке

### Этап 11: Документация

1. **Создание документации по API**
   - Описать все API эндпоинты
   - Привести примеры запросов и ответов

2. **Создание документации по использованию**
   - Описать порядок установки и запуска
   - Привести примеры использования

## Детали реализации основных компонентов

### Конкурентная обработка данных
1. **Fan-In Pattern**: Создать функцию, которая объединяет данные из нескольких каналов в один.
2. **Fan-Out Pattern**: Создать функцию, которая распределяет данные из одного канала на несколько.
3. **Worker Pool**: Создать пул воркеров, которые будут обрабатывать данные из каналов.

### Хранение данных
1. **PostgreSQL**: Создать таблицу для хранения агрегированных данных.
2. **Redis**: Хранить последние цены в кеше для быстрого доступа.

### API
1. **REST API**: Реализовать все требуемые эндпоинты.
2. **Health checks**: Реализовать проверку состояния системы.



### План работы с Redis и PostgreSQL
Вот примерный порядок действий для каждого цикла обработки данных:

## Получение новых данных:

Извлекаем новые данные о ценах с источников (обменников или генераторов в тестовом режиме).

Немедленно записываем эти данные в Redis, чтобы обеспечить быстрый доступ к последней информации.

## Агрегация данных и запись в PostgreSQL:

Раз в минуту собираем все обновления за последний интервал времени (например, за последнюю минуту).

Вычисляем среднюю цену, минимальную цену и максимальную цену для каждой валютной пары.

Сохраняем эти агрегированные данные в PostgreSQL для долговременного хранения.

## Кэширование и восстановление из Redis:

Когда приходит запрос на цену для конкретной валютной пары, сначала обращаемся к Redis для получения самой актуальной цены.

Если Redis по какой-то причине недоступен, можем обратиться к PostgreSQL для получения данных о последних обновлениях.

## Чистка данных:

В Redis важно удалять устаревшие данные (например, данные, которые не обновлялись больше минуты). Это можно делать через TTL (время жизни) или вручную.

В PostgreSQL данные должны храниться долго, но могут быть архивированы или удалены по мере роста объема данных.

### порядок операций
1 шаг: Когда данные поступают (из exchange или тестового генератора), немедленно сохраняем их в Redis для быстрой доступности.

2 шаг: Каждую минуту агрегируем данные, вычисляем среднюю цену, максимальную и минимальную цену за этот период.

3 шаг: Сохраняем агрегированные данные в PostgreSQL.

4 шаг: Если Redis не доступен, обращаемся к PostgreSQL для получения данных.